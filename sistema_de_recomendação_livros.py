# -*- coding: utf-8 -*-
"""Sistema de Recomendação - Livros.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_zbEOkknUBn_o5XfDgUarp2HYzVEh9t9

#IMPORTANDO BIBLIOTECAS
"""

# Frameworks

# Modelagem de dados
import pandas as pd # Dados
import numpy as np # Matrizes

# Analises graficas
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

# Avisos
import warnings
warnings.filterwarnings('ignore')

# Ajustes no pandas
pd.set_option('display.max_rows', 100 ) # Linhas
pd.set_option('display.max_columns', 50 ) # Colunas
 
# Ajustes no matplot
plt.rcParams['figure.figsize'] = (15, 6)  # Tamanho do gráfico
plt.style.use('seaborn-darkgrid') # Estilo do gráfico

"""# **Importação dos dados**"""

# Ler os dados
Dados_Livros = pd.read_csv('Books.csv')
Dados_Avaliacao = pd.read_csv('Ratings.csv')
Dados_Usuario = pd.read_csv('Users.csv')

# Dimensçao [ Linhas, Colunas ]
Dados_Livros.shape, Dados_Avaliacao.shape, Dados_Usuario.shape

# Primeiras Linhas
Dados_Livros.head()

# Info
Dados_Livros.info()

# Verificando
Dados_Avaliacao.head()  # Avaliação de 0 até 10

# Info
Dados_Avaliacao.info()

# Verficando
Dados_Usuario.head()

# Info
Dados_Usuario.info()

"""# **Modelagem dos dados**"""

# Cruzamentos dos dados

# 1º Cruzamento
Tab_Cruzada = Dados_Livros.merge( Dados_Avaliacao, how='inner', on='ISBN')

# 2º Cruzamento
Tab_Cruzada = Tab_Cruzada.merge( Dados_Usuario, how='inner', on='User-ID')

# Dimensão
Tab_Cruzada.shape

# Verificar
Tab_Cruzada.head()

# VErificar
Tab_Cruzada.info()

'''
  Investigação dos ruidos na base

  for Linha in Tab_Cruzada['Year-Of-Publication'].value_counts().index :
    print( Linha )

  Tab_Cruzada.loc[ Tab_Cruzada['Year-Of-Publication'] == 'DK Publishing Inc' ]

'''


# Ajustando o registro incorreto
Tab_Cruzada.iloc[ 287500, 3 ] = ''
Tab_Cruzada.iloc[ 352361, 3 ] = ''
Tab_Cruzada.iloc[ 467962, 3 ] = ''
Tab_Cruzada.iloc[ 469216, 3 ] = ''

# Conveter a coluna Ano
Tab_Cruzada['Year-Of-Publication'] = pd.to_numeric( Tab_Cruzada['Year-Of-Publication'] )

# Formato das Colunas
Tab_Cruzada.dtypes

# Verificando
Tab_Cruzada['Location'].head(5)

# Verificando
Tab_Cruzada['Location'].tail(5)

# Tecnica de tratamento de texto
def Extrair_Pais( Regiao ):
  '''
    Função para extrair o nome do pais na coluna região
  '''
  # Incluindo a inforção
  Registro = Regiao
  # Fatiar
  Registro = Regiao.split(',')
  # Buscar
  Fracao = Registro[-1].upper()
  #Retorno
  return Fracao

# Criando a coluna
Tab_Cruzada['Pais'] = Tab_Cruzada['Location'].apply( Extrair_Pais )

# Verificando
Tab_Cruzada.head()

# Nulos
Tab_Cruzada.isnull().sum()

# Unicos
Tab_Cruzada.nunique()

# Renomar as colunas
Tab_Cruzada.rename(
    columns={
        'Book-Title' : 'Titulo',
        'Book-Author' : 'Autor',
        'Year-Of-Publication' : 'Ano_Publicacao',
        'Publisher' : 'Editora',
        'User-ID' :'Id_Cliente',
        'Book-Rating' : 'Avaliacao',
        'Location' : 'Localizacao',
        'Age' : 'Idade'
    }, inplace=True
)

# Verificar
Tab_Cruzada.columns

"""# **Data Visualization - Exploração**"""

# Analise descritiva
Tab_Cruzada.describe()

# Remover as avaliações zeradas
Tab_Cruzada = Tab_Cruzada.loc[ Tab_Cruzada['Avaliacao'] > 0 ]

# Veriicar
Tab_Cruzada.isnull().sum(), Tab_Cruzada.shape

# Verificar
Tab_Cruzada['Avaliacao'].describe()

# Analise grafica
plt.title('Analisando a avaliação')
sns.boxplot( data=Tab_Cruzada, x='Avaliacao');

# Analise
Analise = Tab_Cruzada.groupby( by=['Titulo'] ).agg(
    Quantidade = ('Titulo', 'count'),
    Media = ('Avaliacao', 'mean'),
    Max = ('Avaliacao', 'max'),
    Min = ('Avaliacao', 'min'),
    Mediana = ('Avaliacao', 'median'),
)

# Verificando
Analise.head()

# Verificar
Analise.sort_values('Quantidade', ascending=False ).head()

# Vericar
Analise.sort_values(['Media', 'Quantidade' ], ascending=False ).head()

# Analise Qtd x Avaliacao

px.scatter(
    # Dados
    data_frame=Analise,
    # Parametros
    x='Quantidade', y='Media',
    # Titulo
    title='Média x Quantidade - Titulos',
    # Upgrade
    # marginal_y='rug', marginal_x='histogram'
)

# Correlação
Analise.corr()

# Analise
Analise['Quantidade'].describe()

# 
def Classificao_Quantidade( Quantidade ):
  '''
    Agrupar a quantidade
  '''

  if int( Quantidade ) <= 5:
    return '1-5 Avaliações'

  elif int( Quantidade) <=10:
    return '6-10 Avaliações'

  elif int(Quantidade) <= 50:
    return '11-50 Avaliações'

  elif int(Quantidade) <= 100:
    return '51-100 Avaliações'

  else:
    return '>101 Avaliações'

# Aplicação
Pizza = Analise['Quantidade'].apply( Classificao_Quantidade ).value_counts( normalize=True )

# Tranformar em um DataFrame
Pizza = pd.DataFrame( Pizza ).reset_index()

# Plot
px.pie( 
    # DAdos
    data_frame=Pizza,
    # Paramewtros
    names='index', values='Quantidade',
    # Titulo
    title='Divisão das Quantidades'
)

# Verificando
Pizza

# Publicação
Anlaise_Ano = Tab_Cruzada['Ano_Publicacao'].value_counts().sort_index().reset_index()

# Verificando
Anlaise_Ano.describe()

# Plot

# Filtrando o ano
Filtro = Anlaise_Ano.loc[ (Anlaise_Ano['index'] > 1990) & ( Anlaise_Ano['index'] < 2020 ) ]

# Plot
plt.title('Analisando ano de publicação')
plt.bar( Filtro['index'], Filtro['Ano_Publicacao'] );

Tab_Cruzada.columns

# Ranikg dos Autores
Tab_Cruzada.groupby( by='Autor' ).agg(
    Quantidade = ('Avaliacao', 'count'),
    Media = ('Avaliacao', 'mean'),
).sort_values('Quantidade', ascending=False ).head(10)

# Concetração das avaliações
Tab_Cruzada['Pais'].value_counts( normalize=True ).head(10) * 100

# Concetração das avaliações
Tab_Cruzada['Pais'].value_counts( normalize=True ).cumsum().head(10) * 100

# Idade
plt.title('Análise das idades')
sns.boxplot( data=Tab_Cruzada, x='Idade' );

"""# **Construção do Modelo**"""

# Ajustar ( Avaliação dos Livros --> Tab_Cruzada )

# Ajustando a Tabela de Avaliacoes
Avaliacoes = Analise.reset_index().iloc[:, 0:2]

# Cruzando os dados
Tab_Final = Tab_Cruzada.merge( Avaliacoes, how='inner', on='Titulo' )

# VErificando
Tab_Final.head()

# Filtrar
Livros_Avaliados = Tab_Final.loc[ Tab_Final['Quantidade'] >= 50 ]

# Dimensao
Livros_Avaliados.shape

# Duplicados
Livros_Avaliados.duplicated().sum()

# Gerar a Metriz 
Matriz = Livros_Avaliados.pivot_table( values='Avaliacao', index='Titulo', columns='Id_Cliente' )

# Retirar os NAN
Matriz.fillna( 0, inplace=True)

# VErificar
Matriz.head()

# Verificando
Tab_Cruzada.loc[ Tab_Cruzada['Titulo'] == '1984' ].head()

# Trnasformação para vetores
from scipy.sparse import csc_matrix
Matriz_Sparse = csc_matrix( Matriz )

Matriz_Sparse

# Exemplo da função
csc_matrix(  (4, 4), dtype=np.int8 ).toarray()

# Criar o Modelo
from sklearn.neighbors import NearestNeighbors

# Parametros
Modelo = NearestNeighbors(
    # Quantidade de recomendações
    n_neighbors=5,
    # Algoritmo
    algorithm='brute',
    # metrica de distancia
    metric='minkowski'
)

# Fitar o modelo
Modelo.fit( Matriz_Sparse )

# Recomendações
# Escolher_Livro

# Descobrir Libros Harry
for Posicao, Titulo in enumerate(Matriz.index):

  # Harry
  if 'Harry' in Titulo:
    print( Posicao, Titulo )

# Seleionando o Livro ##### CLIENTE COMPROU !!!!!! ######
Selecionar_Livro = Matriz.iloc[ 213, :].values.reshape( 1, -1 )

# Previsão do Modelo
Distancia, Recomendacao = Modelo.kneighbors( Selecionar_Livro )

## AVALIAÇAO / RENTABILIDADE /  SERIES / NOTICIAS

#### RECOMENDAÇÔES ######
# Ver as sugestões
for Loop in range( len(Recomendacao) ):

  print( Matriz.index[ Recomendacao[Loop] ] )

Distancia

"""# **Entedimento do Algoritmo**"""

# Matriz
Dados = np.array(
    [
        [5, 5],
        [4, 3],
        [8, 2],
        [5, 8],
        [6, 5],
        [2, 1]
    ]
)

# Tabela exemplo
Tabela_Exemplo = pd.DataFrame( Dados )
Tabela_Exemplo

# Plot
plt.title('Analise', loc='left')
sns.scatterplot( data=Tabela_Exemplo, x=0, y=1, s=300);

# Treinar o modelo
Modelo_Exemplo = NearestNeighbors( n_neighbors=2, metric='euclidean')
Modelo_Exemplo.fit( Dados )

# Fazendo a recomendação
Distancias, Indices = Modelo_Exemplo.kneighbors( [[7, 3]] )

print( Distancias )
print( Indices )

# Plot
plt.title('Analise compração', loc='left')
sns.scatterplot( data=Tabela_Exemplo, x=0, y=1, s=300)

Previsor = pd.DataFrame( [[7, 3]] )
sns.scatterplot( data=Previsor, x=0, y=1, s=300)
plt.legend(['Dados Reais', 'PRevisor']);

"""![image.png](data:image/png;base64,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)"""

# Calculo 
import math

# Loop na base  de dados
for Col1, Col2  in zip( Tabela_Exemplo[0], Tabela_Exemplo[1] ):

  # Calculando distancia euclidiana
  Distancia = math.sqrt( (( 7 - Col1 ) ** 2) + (( 3 - Col2 ) ** 2) )

  print( Col1, Col2, 'Distâncias dos dados: ', round( Distancia, 6 ) )

"""# **Simulador**"""

# Frameworks
# Plotar a imagem
import PIL
import urllib
import requests
import matplotlib.image as mpimg

# Filtrando o link da capa do Harry poter
Link = Tab_Cruzada.loc[ Tab_Cruzada['Titulo'] == 'Harry Potter and the Chamber of Secrets (Book 2)' ].head(1)['Image-URL-L'].values[0]

# Buscar as informações
Imagem = PIL.Image.open( urllib.request.urlopen( Link ) )

Imagem

# Lista para receber os links das recomendações
Lista_URL = []

# Loop nas recomendações
for Loop in range( len(Recomendacao) ):

  # Filtro na matriz
  Selecao_Loop = ( Matriz.index[ Recomendacao[Loop] ] )

  # Atribuindo a Lista
  Lista_URL = Selecao_Loop


# Filtrando o link das recomendações
Link_Recomendao_01 = Tab_Cruzada.loc[ Tab_Cruzada['Titulo'] == Lista_URL[1] ].head(1)['Image-URL-L'].values[0]
Link_Recomendao_02 = Tab_Cruzada.loc[ Tab_Cruzada['Titulo'] == Lista_URL[2] ].head(1)['Image-URL-L'].values[0]
Link_Recomendao_03 = Tab_Cruzada.loc[ Tab_Cruzada['Titulo'] == Lista_URL[3] ].head(1)['Image-URL-L'].values[0]
Link_Recomendao_04 = Tab_Cruzada.loc[ Tab_Cruzada['Titulo'] == Lista_URL[4] ].head(1)['Image-URL-L'].values[0]

# atribuindo as imagens
Imagem_01 = PIL.Image.open( urllib.request.urlopen( Link_Recomendao_01 ) )
Imagem_02 = PIL.Image.open( urllib.request.urlopen( Link_Recomendao_02 ) )
Imagem_03 = PIL.Image.open( urllib.request.urlopen( Link_Recomendao_03 ) )
Imagem_04 = PIL.Image.open( urllib.request.urlopen( Link_Recomendao_04 ) )

# Construir relatorio
import plotly.graph_objects as Go
from plotly.subplots import make_subplots

Titulos = ['Seleção', 'Recomendação 1', 'Recomendação 2', 'Recomendação 3', 'Recomendação 4']

# Criando a Figura
Figura = make_subplots(
    rows=1,
    cols=5,
    subplot_titles=Titulos
)

# Ajustando o layout
Figura.update_layout(
    height=500,
    width=1200,
    title_text='Sistema de recomendação',
    showlegend=False
)

# Imagem da Seleção
Figura.add_trace(
    Go.Image(
        z=Imagem,
    ),
    row=1, col=1
)

# Imagem da Recomendação 1
Figura.add_trace(
    Go.Image(
        z=Imagem_01,
    ),
    row=1, col=2
)

# Imagem da Recomendação 2
Figura.add_trace(
    Go.Image(
        z=Imagem_02,
    ),
    row=1, col=3
)

# Imagem da Recomendação 3
Figura.add_trace(
    Go.Image(
        z=Imagem_03,
    ),
    row=1, col=4
)

# Imagem da Recomendação 4
Figura.add_trace(
    Go.Image(
        z=Imagem_04,
    ),
    row=1, col=5
)

# Mostrar
Figura.show()

